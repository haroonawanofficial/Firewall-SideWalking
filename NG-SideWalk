import argparse
import logging
import random
import socket
from concurrent.futures import ThreadPoolExecutor
from time import sleep
from datetime import datetime
from scapy.all import *
from scapy.layers.inet import IP, TCP, ICMP, IPOption
from scapy.layers.http import HTTPRequest
from colorama import Fore, Style, init
from tabulate import tabulate
import ipaddress

# Initialize colorama
init(autoreset=True)

# Setup basic logging
logging.basicConfig(filename='advanced_scan_log.txt', level=logging.DEBUG, format='%(asctime)s - %(message)s')

# Define evasion techniques
evasion_techniques = ["Randomized Source IP", "Randomized Payload", "Variable Packet Sizes"]

# Define a function to parse arguments
def parse_args():
    parser = argparse.ArgumentParser(description="Advanced Network Scanner")
    parser.add_argument('--target', required=True, help='IP range or host to scan (comma-separated or CIDR)')
    parser.add_argument('--ports', type=str, default="80,443", help='Ports to scan, comma-separated')
    parser.add_argument('--spoof-ip', type=str, default=None, help='IP address to spoof')
    parser.add_argument('--rate', type=float, default=1.0, help='Delay between packets to avoid detection (in seconds)')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads for scanning')
    return parser.parse_args()

# Define a function to perform a scan
def perform_scan(scan_type, packet, target_ip, target_port, spoofed_ip=None):
    if spoofed_ip:
        packet[IP].src = spoofed_ip
    response = sr1(packet, timeout=1, verbose=False)
    scan_success = "Yes" if response else "No"
    firewall_detected = "Yes" if not response else "No"
    return [scan_type, target_ip, target_port, scan_success, firewall_detected]

# Define a function to resolve target
def resolve_target(target):
    try:
        return socket.gethostbyname(target)
    except socket.gaierror:
        return target

# Define a function to print scan results
def print_scan_results(scan_results):
    headers = ["Scan Type", "IP", "Port", "Success", "Firewall Detected", "Infiltration Method"]
    table = []
    for item in scan_results:
        if item[3] == "Yes":
            method = "Use this scan method to infiltrate and bind a virus or port"
        else:
            method = "Try other evasion techniques"
        row = [Fore.GREEN + str(item[0]) + Style.RESET_ALL, item[1], item[2], item[3], item[4], method]
        table.append(row)
    print(tabulate(table, headers=headers, tablefmt="grid"))

# Define a function to generate target IPs from CIDR
def generate_target_ips(cidr):
    try:
        network = ipaddress.ip_network(cidr, strict=False)
        return [str(ip) for ip in network.hosts()]
    except ValueError:
        return [cidr]

# Define scan functions
def reverse_ip_scan(target_ip, target_port):
    packet = IP(dst=target_ip, src=target_ip)/ICMP()
    return perform_scan("Reverse IP Scan", packet, target_ip, target_port)

def custom_ip_options_scan(target_ip, target_port):
    packet = IP(dst=target_ip, options=[IPOption(b'\x82\x04\x00\x00')])/ICMP()
    return perform_scan("Custom IP Options Scan", packet, target_ip, target_port)

def icmp_source_quench_scan(target_ip, target_port):
    packet = IP(dst=target_ip)/ICMP(type=4)
    return perform_scan("ICMP Source Quench Scan", packet, target_ip, target_port)

def custom_tcp_option_scan(target_ip, target_port):
    packet = IP(dst=target_ip)/TCP(dport=target_port, options=[(0x42, b'\x01\x02\x03\x04')])
    return perform_scan("Custom TCP Option Scan", packet, target_ip, target_port)

def custom_payload_tcp_scan(target_ip, target_port):
    packet = IP(dst=target_ip)/TCP(dport=target_port)/Raw(load="CustomPayload")
    return perform_scan("Custom Payload TCP Scan", packet, target_ip, target_port)

# Define a function for stealth scanning
def stealth_scan(target, ports, spoof_ip=None, delay=1.0):
    for port in ports:
        packet = IP(dst=target, src=spoof_ip if spoof_ip else None)/TCP(dport=port, flags="S")
        response = sr1(packet, timeout=1, verbose=False)
        if response and response.haslayer(TCP) and response.getlayer(TTCP).flags == 0x12:
            logging.info(f"Port {port} on {target} is open.")
            if spoof_ip is None:  # Only if not spoofing, to avoid stateful firewall detection
                send(IP(dst=target)/TCP(dport=port, flags="A"), verbose=False)
        sleep(delay)

# Define the main function
def main():
    args = parse_args()
    targets = []
    if '/' in args.target:
        targets = generate_target_ips(args.target)
    else:
        targets = [resolve_target(t) for t in args.target.split(',')]
    ports = [int(p) for p in args.ports.split(',')]
    spoof_ip = args.spoof_ip
    delay = args.rate

    scan_results = []
    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = []
        for target in targets:
            for port in ports:
                futures.append(executor.submit(reverse_ip_scan, target, port))
                futures.append(executor.submit(custom_ip_options_scan, target, port))
                futures.append(executor.submit(icmp_source_quench_scan, target, port))
                futures.append(executor.submit(custom_tcp_option_scan, target, port))
                futures.append(executor.submit(custom_payload_tcp_scan, target, port))
                futures.append(executor.submit(stealth_scan, target, ports, spoof_ip, delay))

        for future in futures:
            scan_results.append(future.result())

    print_scan_results(scan_results)
    logging.info("Scanning completed.")

if __name__ == "__main__":
    main()
